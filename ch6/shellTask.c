/*이는 정수형 데이터로 입력받는 셸정렬 알고리즘에 구조체 형으로 변형해서 구현한
셸 정렬 알고리즘이다. (다만 이 알고리즘은 안정적이지 않음)*/
// #include <stdio.h>
// #include <stdlib.h>

// void shell(int a[], int n)
// {
//     int h;
//     for (h = 1; h < n; h = h * 3 + 1)
//         ;
//     for (; h > 0; h /= 3)
//         for (int i = h; i < n; i++)
//         {
//             int tmp = a[i];
//             int j;
//             for (j = i - h; j >= 0 && a[j] > tmp; j -= h)
//                 a[j + h] = a[j];
//             a[j + h] = tmp;
//         }
// }

// int main(void)
// {
//     int nx;

//     puts("셸 정렬");
//     printf("요소 개수 : ");
//     scanf("%d", &nx);
//     int *x = calloc(nx, sizeof(int));

//     for (int i = 0; i < nx; i++)
//     {
//         printf("x[%d]: ", i);
//         scanf("%d", &x[i]);
//     }
//     shell(x, nx);

//     puts("오름차순으로 정렬했습니다.");
//     for (int i = 0; i < nx; i++)
//         printf("x[%d] = %d\n", i, x[i]);
//     free(x);

//     return 0;
// }
/*--- 위 코드는 기존의 정수형 데이터로 입력을 받는 코드임
- calloc을 사용하여 정수 배열을 할당하고, 사용자의 입력을 읽고, 셸 정렬 알고리즘을
사용하여 데이터를 정렬하고, 결과를 콘솔에 출력*/

/*--- 아래 코드는 수정된 코드입니다. 사용자 젖의 구조 유형을 사용하여
정렬 중인 데이터를 나타냄, 구조체에는 데이터 값을 나타내는 단일 정수 필드가
포함 되어 있고, calloc을 사용하여 구조체의 배열을 할당하고, 사용자의 입력을 읽으며, 구조체 데이터와
함께 작동하는 셸 정렬 알고리즘을 사용하여 데이터를 정렬하고, 결과를 콘솔에 출력*/

#include <stdio.h>
#include <stdlib.h>

typedef struct
{
    int key;
} Element;

void shell(Element a[], int n)
{
    int h;
    for (h = 1; h < n; h = h * 3 + 1)
        ;
    for (; h > 0; h /= 3)
        for (int i = h; i < n; i++)
        {
            Element tmp = a[i];
            int j;
            for (j = i - h; j >= 0 && a[j].key > tmp.key; j -= h)
                a[j + h] = a[j];
            a[j + h] = tmp;
        }
}

int main(void)
{
    int nx;

    puts("셸 정렬");
    printf("요소 개수 : ");
    scanf("%d", &nx);
    Element *x = calloc(nx, sizeof(Element));

    for (int i = 0; i < nx; i++)
    {
        printf("x[%d]: ", i);
        scanf("%d", &x[i].key);
    }
    shell(x, nx);

    puts("오름차순으로 정렬했습니다.");
    for (int i = 0; i < nx; i++)
        printf("x[%d] = %d\n", i, x[i].key);
    free(x);

    return 0;
}
/*------- 안정성 문제 -------------
정수 데이터를 구조체 유형으로 변환하면 메모리 할당, 유형 안정성, 성능 및 이식성 문제와 같은 몇가지
안정적 문제가 발생할 수 있음,

1. 메모리 할당
수정된 코드는 정수 배열 대신 calloc을 사용하여 구조체 배열을 할당함, 구조체가 올바르게 할당
되지 않은 경우 메모리 할당 오류가 발생할 위험이 있음, 추가적으로 구조체의 크기가
올바르지 않거나 프로그램이 할당된 구조체의 범위를 벗어난 메모리에 액세스 하는 경우 세그먼테이션 오류와 같은 메모리
관련 오류가 발생할 수 있습니다.

2. 유형 안전
수정된 코드는 정수 필드를 포함하는 사용자 정의 구조 유형에서 작동, 이로 인해 프로그램이 정수를 예상하는 함수에 구조체를 전달하거나 그 반대의 경우 형식 안전 오류가
발생할 위험이 있음, 프로그램이 실수로 구조체의 다른 필드를 비교 또는
수정하거나 데이터를 손상시키는 방식으로 정수 데이터를 수정하는 함수에 구조체를 
전달하면 유형 관련 오류가 발생할 수 있음

3. 성능
수정된 코드는 단순 정수 데이터 유형 대신 사용자 정의 구조 유형을 사용
구조를 조작하려면 더 많은 메모리와 더 복잡한 작업이 필요할 수 있으므로 성능 문제의 위험이 있음
프로그램이 대규모 데이터 세트 또는 성능에 중요한 코드로 작업하는 경우
이러한 문제의 영향을 최소화하기 위해 코드를 최적화 해야할 수도 있음

4. 휴대성 
수정된 코드는 다른 프로그램에서 다르게 구현 될 수 있는 사용자 정의 구조 유형을 사용
이것은 프로그램이 구조 레이아웃 또는 메모리 정렬에 대한 특정 가정에 의존하는 경우 이식성 문제의 위험을 초래합니다. 프로그램이
다른 플랫폼에서 철저하게 테스트되지 않으면 모든 플랫폼에서 제대로 작동하지 않을 수 있습니다.

5. 결론
결론적으로 정수형 데이터를 구조체 유형으로 변환하면 프로그램이 올바르고 안정적으로 작동하도록 하기 위해
해결해야 하는 몇 가지 안정성과 문제가 발생할 수 있습니다. 수정된 코드는 원래
코드에 비해 추가적인 복잡성과 잠재적인 분할을 야기하지만 올바르게 구현되고 철저하게 테스트만 된다면 그 만큼 안전할 수 있습니다.*/